asTheEconomist(
xyplot(v ~ time | factor(I), data=sims, type="l",
as.table=TRUE,
main="Hodgkin-Huxley model with varying external stimulus"),
xlab="time (ms)" , ylab="mV")
?sim
install.packages("WebPower")
wp.correlation(r=0.46, power=0.8, alpha=0.05, alternative = "two.sided")
rm(list = ls())
avonet_data <- read.csv("data/avonet_data.csv")
# Load the dplyr package to use filter.
library(dplyr)
# Filter will subset our trait data based on the Jetz family column.
turdi_data <- avonet_data %>% filter(jetz_family == "Turdidae")
# First load in the spatial packages we'll need.
library(raster)
library(sf)
# Load the data into our environment.
load("/cloud/project/data/Turdidae_range_data.RData")
class(turdi_ranges)
# And lets add a column to our data for storing if it's a small or large range.
turdi_data$range_large <- NA
# We'll use a basic loop that goes from 1 to 237.
row_numbers <- 1:nrow(turdi_data)
# The curly brackets show the beginning and the end of the loop.
for (x in row_numbers){
# Pull out the range size we want for each iteration (x) of the loop.
range <- turdi_data$range_size[x]
# Calculate if it's small range or a large range.
if (is.na(range) > 1000000) {
range_large <- 1
}
else {
range_large <- 0
}
# Lastly we want to add our new value to the dataframe.
turdi_data$range_large[x] <- range_large
}
# Load fasterize package.
library(fasterize)
# Combine the two datasets into one object so we have range size info and the polygons together.
# This turns our sf object into a normal dataframe.
turdi_all <- left_join(turdi_data, turdi_ranges, by = c("jetz_name" = "SCINAME"))
# Start by creating an empty raster stack to store our data in.
raster_template <- raster(ncols=2160, nrows = 900, ymn = -60)
# 'fasterize' needs objects to be an sf class so we'll convert it back.
turdi_all <- st_sf(turdi_all)
# Use the fasterize function with the raster template. We want to use the
# range_large field, and the function min takes the smallest value when they overlap.
# (so small ranges are shown on top of large ranges)
range_raster <- fasterize(turdi_all, raster_template, field = "range_large", fun = "min")
library(tidyr)
library(ggplot2)
# Convert the raster into a raster dataframe.
raster_data <- as.data.frame(range_raster, xy=TRUE) %>% drop_na()
colnames(raster_data) <- c("long", "lat", "index")
# Add labels for the range sizes so that ggplot colours them as discrete, rather than a continuous number.
raster_data$ranges[raster_data$index == 0] <- "Small"
raster_data$ranges[raster_data$index == 1] <- "Large"
# We can then plot this in ggplot. We have to first create the colour scheme for our map.
myColors <- c("grey80", "red")
# Assign names to these colors that correspond to each range size.
names(myColors) <- unique(raster_data$ranges)
# Create the colour scale.
colScale <- scale_fill_manual(name = "Range Sizes", values = myColors)
# Create a plot with ggplot (the plus signs at the end of a line carry over to the next line).
range_plot <- ggplot() +
# borders imports all the country outlines onto the map.
# colour changes the colour of the outlines,
# fill changes the colour of the insides of the countries.
# This will grey out any terrestrial area which isn't part of a range.
borders(ylim = c(-60,90), fill = "grey90", colour = "grey90") +
# Borders() xlim is -160/200 to catch the edge of Russia. We need to reset the
# xlim to -180/180 to fit our raster_stack.
xlim(-180, 180) +
# Add the range information on top.
geom_tile(aes(x=long, y=lat, fill= ranges), data=raster_data) +
# Add colours.
colScale +
# Add title.
ggtitle("Small range sizes in the Accipitidae") +
# Add the classic theme (things like gridlines, font etc.)
theme_classic() +
# Add axes labels.
ylab("Latitude") +
xlab("Longitude") +
# coord_fixed() makes ggplot keep our aspect ratio the same.
coord_fixed()
library(fasterize)
library(readr)
modeldata <- read_csv("Desktop/fyp/data/modeldata.csv")
View(modeldata)
library(readr)
p_abies_data_with_environmental_variables <- read_csv("Desktop/fyp/data/p. abies data with environmental variables.csv")
View(p_abies_data_with_environmental_variables)
View(p_abies_data_with_environmental_variables)
library(readr)
r_ochroleuca_data_with_environmental_variables <- read_csv("Desktop/fyp/data/r. ochroleuca data with environmental variables.csv")
View(r_ochroleuca_data_with_environmental_variables)
M <- matrix(runif(1000000),1000,1000)
SumAllElements <- function(M) {
Dimensions <- dim(M)
Tot <- 0
for (i in 1:Dimensions[1]) {
for (j in 1:Dimensions[2]) {
Tot <- Tot + M[i,j]
}
}
return (Tot)
}
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))
print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
NoPreallocFun <- function(x) {
a <- vector() # empty vector
for (i in 1:x) {
a <- c(a, i) # concatenate
print(a)
print(object.size(a))
}
}
system.time(NoPreallocFun(10))
PreallocFun <- function(x) {
a <- rep(NA, x) # pre-allocated vector
for (i in 1:x) {
a[i] <- i # assign
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
PreallocFun <- function(x) {
a <- rep(NA, x) # pre-allocated vector
for (i in 1:x) {
a[i] <- i # assign
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
NoPreallocFun <- function(x) {
a <- vector() # empty vector
for (i in 1:x) {
a <- c(a, i) # concatenate
print(a)
print(object.size(a))
}
}
system.time(NoPreallocFun(10))
NoPreallocFun <- function(x) {
a <- vector() # empty vector
for (i in 1:x) {
a <- c(a, i) # concatenate
print(a)
print(object.size(a))
}
}
system.time(NoPreallocFun(10))
PreallocFun <- function(x) {
a <- rep(NA, x) # pre-allocated vector
for (i in 1:x) {
a[i] <- i # assign
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
system.time(NoPreallocFun(10))
system.time(PreallocFun(10))
NoPreallocFun <- function(x) {
a <- vector() # empty vector
for (i in 1:x) {
a <- c(a, i) # concatenate
#print(a)
#print(object.size(a))
}
}
PreallocFun <- function(x) {
a <- rep(NA, x) # pre-allocated vector
for (i in 1:x) {
a[i] <- i # assign
#print(a)
#print(object.size(a))
}
}
system.time(NoPreallocFun(1000))
system.time(PreallocFun(1000))
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)
## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)
## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)
## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)
someoperation <- function(v) {
if (sum(v) > 0) {
return (v * 100)
} else {
return (v)
}
}
M <- matrix(rnorm(100), 10 , 10)
print (apply(M, 1, someoperation))
######### Functions ##########
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n) {
pop_sample <- sample(popn, n, replace = FALSE)
return(mean(pop_sample))
}
## Calculate means using a FOR loop on a vector without preallocation:
loopy_sample1 <- function(popn, n, num) {
result1 <- vector() #Initialize empty vector of size 1
for(i in 1:num) {
result1 <- c(result1, myexperiment(popn, n))
}
return(result1)
}
## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(,num) #Preallocate expected size
for(i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
result3 <- vector("list", num) #Preallocate expected size
for(i in 1:num) {
result3[[i]] <- myexperiment(popn, n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
result5 <- sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
set.seed(12345)
popn <- rnorm(10000) # Generate the population
hist(popn)
n <- 100 # sample size for each experiment
num <- 10000 # Number of times to rerun the experiment
print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))
print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))
print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))
print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))
print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))
Exponential <- function(N0 = 1, r = 1, generations = 10) {
# Runs a simulation of exponential growth
# Returns a vector of length generations
N <- rep(NA, generations)    # Creates a vector of NA
N[1] <- N0
for (t in 2:generations) {
N[t] <- N[t-1] * exp(r)
browser()
}
return (N)
}
plot(Exponential(), type="l", main="Exponential growth")
n\c
q
q
doit <- function(x) {
temp_x <- sample(x, replace = TRUE)
if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else {
stop("Couldn't calculate mean: too few unique values!")
}
}
doit <- function(x) {
temp_x <- sample(x, replace = TRUE)
if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else {
stop("Couldn't calculate mean: too few unique values!")
}
}
doit <- function(x) {
temp_x <- sample(x, replace = TRUE)
if(length(unique(temp_x)) > 30) {#only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else {
stop("Couldn't calculate mean: too few unique values!")
}
}
set.seed(1345)
popn <- rnorm(50)
hist(popn)
lapply(1:15, function(i) doit(popn))
result <- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)
result
result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
result[[i]] <- try(doit(popn), FALSE)
}
result <- vector("list", 15) #Preallocate/Initialize
for(i in 1:15) {
result[[i]] <- tryCatch(doit(popn), FALSE)
}
##experiment with trycatch##
install.packages(c("tidyverse"))
library(tidyverse)
setwd("~/Documents/CMEEcoursework/week3/code")
mydata <- as.matrix(read.csv("../data/PoundHillData.csv", header  = FALSE))
mydata <- as.matrix(read.csv("../data/PoundHillData.csv", header  = FALSE))
class(mydata)
mydata <- as.matrix(read.csv("../data/PoundHillData.csv", header  = FALSE))
class(mydata)
mymetadata <- read.csv("../data/PoundHillMetaData.csv", header  = TRUE, sep = ";"))
mymetadata <- read.csv("../data/PoundHillMetaData.csv", header  = TRUE, sep = ";")
class(mymetadata)
View(mydata)
View(mymetadata)
mydata[mydata == ""] = 0
library(reshape2)
#converting the data from wide to long format
mydata <- t(mydata) #transposing the data
head(mydata)
colnames(mydata)
tempdata <- as.data.frame(mydata[-1,], stringsAsFactors = F)
head(tempdata)
colnames(tempdata) <- mydata[1,] #assigning column names from original data
head(tempdata)
rownames(tempData) <- NULL #getting rid of row names
rownames(tempdata) <- NULL #getting rid of row names
head(tempdata)
rownames(tempdata) <- NULL #getting rid of row names
head(tempdata)
require(reshape2)
mywrangleddata <- melt(tempdatal, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
mywrangleddata <- melt(tempdata, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
head(mywrangleddata); tail(mywrangleddata)
mywrangleddata[, "Cultivation"] <- as.factor(mywrangleddata[, "Cultivation"])
mywrangleddata[, "Block"] <- as.factor(mywrangleddata[, "Block"])
mywrangleddata[, "Plot"] <- as.factor(mywrangleddata[, "Plot"])
mywrangleddata[, "Quadrat"] <- as.factor(mywrangleddata[, "Quadrat"])
mywrangleddata[, "Count"] <- as.integer(mywrangleddata[, "Count"])
str(mywrangleddata)
##data exploration##
require(tidyverse)
#converting the dataframe to a tibble
mywrangleddata <- dplyr::as_tibble(mywrangleddata)
mywrangleddata
glimpse(mywrangleddata)
utils::View(mywrangleddata) #same as fix()
utils::View(mywrangleddata) #same as fix()
filter(mywrangleddata, count>100) #like subset()
filter(mywrangleddata, Count>100) #like subset()
mywrangleddata %>%
group_by(Species) %>%
summarise(avg = mean(Count))
mydf <- read.csv("../data/EcolArchives-E089-51-D1.csv")
dim(MyDF) #check the size of the data frame you loaded
dim(mydf) #check the size of the data frame you loaded
str(mydf)
require(tidyverse)
glimpse(mydf)
mydf$Type.of.feeding.interaction <- as.factor(mydf$Type.of.feeding.interaction)
mydf$Location <-as.factor(mydf$Location)
str(mydf)
#scatterplots
plot(mydf$Predator.mass, mydf$Prey.mass)
plot(log(mydf$Predator.mass), log(mydf$Prey.mass))
#log in r is natural log base e
plot(log10(mydf$Predator.mass), log10(mydf$Prey.mass))
plot(log10(mydf$Predator.mass), log10(mydf$Prey.mass),
pch=20,
xlab = "Predator Mass (g)",
ylab = "Prey Mass (g)")
#histograms
hist(mydf$Predator.mass)
hist(log10(mydf$Predator.mass),
xlab"log10(Predator Mass (g))",
hist(mydf$Predator.mass)
hist(log10(mydf$Predator.mass),
xlab = "log10(Predator Mass (g))",
ylab = "Count") # include labels
hist(log10(mydf$Predator.mass),
xlab = "log10(Predator Mass (g))",
ylab = "Count",
col = "lightblue", border = "pink") #change border and bar colours
hist(log10(mydf$Prey.mass),
xlab = "log10(Prey Mass (g))",
ylab = "Count",
col = "pink", border = "lightblue",
breaks = 10) #change border and bar colours
hist(log10(mydf$Predator.mass),
xlab = "log10(Predator Mass (g))",
ylab = "Count",
col = "lightblue", border = "pink",
breaks = 10) #change border and bar colours
hist(log10(mydf$Prey.mass),
xlab = "log10(Prey Mass (g))",
ylab = "Count",
col = "pink", border = "lightblue",
breaks = 10) #change border and bar colours
par(mfcol=c(2,1)) #initialize multi-paneled plot
par(mfg = c(1,1)) # specify which sub-plot to use first
hist(log10(mydf$Predator.mass),
xlab = "log10(Predator Mass (g))", ylab = "Count", col = "lightblue", border = "pink",
main = 'Predator') # Add title
par(mfg = c(2,1)) # Second sub-plot
hist(log10(mydf$Prey.mass), xlab="log10(Prey Mass (g))",ylab="Count", col = "lightgreen", border = "pink", main = 'prey')
hist(log10(mydf$Predator.mass), # Predator histogram
xlab="log10(Body Mass (g))", ylab="Count",
col = rgb(1, 0, 0, 0.5), # Note 'rgb', fourth value is transparency
main = "Predator-prey size Overlap")
hist(log10(mydf$Prey.mass), col = rgb(0, 0, 1, 0.5), add = T) # Plot prey
legend('topleft',c('Predators','Prey'),   # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))) # Define legend colors
#overlaying plots
hist(log10(mydf$Predator.mass), # Predator histogram
xlab="log10(Body Mass (g))", ylab="Count",
col = rgb(1, 0, 0, 0.5), # Note 'rgb', fourth value is transparency
main = "Predator-prey size Overlap", breaks = 8)
hist(log10(mydf$Prey.mass), col = rgb(0, 0, 1, 0.5), add = T) # Plot prey
legend('topleft',c('Predators','Prey'),   # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))) # Define legend colors
hist(log10(mydf$Predator.mass), # Predator histogram
xlab="log10(Body Mass (g))", ylab="Count",
col = rgb(1, 0, 0, 0.5), # Note 'rgb', fourth value is transparency
main = "Predator-prey size Overlap", breaks = 8)
hist(log10(mydf$Prey.mass), col = rgb(0, 0, 1, 0.5), add = T, breaks = 8) # Plot prey
legend('topleft',c('Predators','Prey'),   # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))) # Define legend colors
hist(log10(mydf$Predator.mass), # Predator histogram
xlab="log10(Body Mass (g))", ylab="Count",
col = rgb(1, 0, 0, 0.5), # Note 'rgb', fourth value is transparency
main = "Predator-prey size Overlap", breaks = 8)
hist(log10(mydf$Prey.mass), breaks = 8, col = rgb(0, 0, 1, 0.5), add = T) # Plot prey
legend('topleft',c('Predators','Prey'),   # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))) # Define legend colors
hist(log10(mydf$Predator.mass),# Predator histogram
breaks = 8,
xlab="log10(Body Mass (g))", ylab="Count",
col = rgb(1, 0, 0, 0.5), # Note 'rgb', fourth value is transparency
main = "Predator-prey size Overlap")
hist(log10(mydf$Prey.mass),
breaks = 8,
col = rgb(0, 0, 1, 0.5), add = T) # Plot prey
legend('topleft',c('Predators','Prey'),   # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))) # Define legend colors
boxplot(log10(mydf$Predator.mass),
xlab = "Location",
ylab = "log10(Predator Mass)",
main = "Predator mass")
boxplot(log(mydf$Predator.mass) ~ mydf$Location,
xlab = "Location", ylab = "Predator Mass",
main = "Predator mass by location")
boxplot(log(mydf$Predator.mass) ~ mydf$Type.of.feeding.interaction,
xlab = "Location", ylab = "Predator Mass",
main = "Predator mass by feeding interaction type")
par(fig=c(0,0.8,0,0.8)) # specify figure size as proportion
plot(log(mydf$Predator.mass),log(mydf$Prey.mass), xlab = "Predator Mass (g)", ylab = "Prey Mass (g)") # Add labels
par(fig=c(0,0.8,0.4,1), new=TRUE)
boxplot(log(mydf$Predator.mass), horizontal=TRUE, axes=FALSE)
par(fig=c(0.55,1,0,0.8),new=TRUE)
boxplot(log(mydf$Prey.mass), axes=FALSE)
mtext("Fancy Predator-prey scatterplot", side=3, outer=TRUE, line=-3)
pdf("../results/Pred_Prey_Overlay.pdf", # Open blank pdf page using a relative path
11.7, 8.3) # These numbers are page dimensions in inches
hist(log(mydf$Predator.mass), # Plot predator histogram (note 'rgb')
xlab="Body Mass (g)", ylab="Count", col = rgb(1, 0, 0, 0.5), main = "Predator-Prey Size Overlap")
hist(log(mydf$Prey.mass), # Plot prey weights
col = rgb(0, 0, 1, 0.5),
add = T)  # Add to same plot = TRUE
legend('topleft',c('Predators','Prey'), # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5)))
graphics.off(); #you can also use dev.off()
pdf("../results/Pred_Prey_Overlay.pdf", # Open blank pdf page using a relative path
11.7, 8.3) # These numbers are page dimensions in inches
hist(log(mydf$Predator.mass), # Plot predator histogram (note 'rgb')
xlab="Body Mass (g)", ylab="Count", col = rgb(1, 0, 0, 0.5), main = "Predator-Prey Size Overlap")
hist(log(mydf$Prey.mass), # Plot prey weights
col = rgb(0, 0, 1, 0.5),
add = T)  # Add to same plot = TRUE
legend('topleft',c('Predators','Prey'), # Add legend
fill=c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5)))
dev.off()
require(ggplot2)
##BEAUTIFUL GRAPHICS IN R##
require(ggplot2)
qplot(Prey.mass, Predator.mass, data = mydf)
qplot(log(Prey.mass), log(Predator.mass), data = mydf)
qplot(log(Prey.mass), log(Predator.mass), data = mydf,
colour = Type.of.feeding.interaction)
#changing aspect ratio using the asp option
qplot(log(Prey.mass), log(Predator.mass), data = mydf,
colour = Type.of.feeding.interaction, asp = 1)
qplot(log(Prey.mass), log(Predator.mass), data = mydf,
shape = Type.of.feeding.interaction, asp = 1)
